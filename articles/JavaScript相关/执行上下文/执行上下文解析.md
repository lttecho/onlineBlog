## 执行上下文与作用域

### 执行上下文保存的是当前代码的执行环境，这个执行环境形成了作用域。

1、上下文里面保存的是代码的执行环境，有了上下文js引擎才知道当前正在执行的代码中的所用到的变量、函数、this等值从哪里来。

2、上下文可以分为：全局上下文、函数上下文、eval上下文（不推荐使用，所以不讨论）。其实全局上下文也可以看做是一个函数上下文，因为全局执行时其实是一个匿名函数在执行（通过看堆栈调用可以看到这点）。

3、很明显，在代码的执行过程中会形成多个执行上下文（就是一个全局上下文+多个函数上下文），这些上下文会在创建是被压入一个栈（称为执行上下文栈），全局上下文一定是栈底，当前正在执行的函数的上下文一定是栈顶，并且只会有当前执行上文是活动的，一旦当前函数执行完毕，就会被弹出栈，下一个上下文成为栈顶，变为活动的上下文。

4、函数执行上下文在函数开始运行时被创建并压入上下文栈，在函数执行完毕后就会被弹出栈并被销毁；全局上下文在代码运行开始就一直存在，在页面关闭后被销毁。



### 上下文的生命周期

生命周期分为三个阶段：创建阶段=》执行阶段=》销毁阶段。

![img](.\上下文生命周期.png)



#### 创建阶段

1、生成变量对象VO

变量对象其实就是一个环境记录对象，而环境记录对象又分为词法环境对象（静态环境对象）和变量环境对象。词法环境对象中保存的是由const声明的不可变变量，变量环境对象中保存的是var、let声明的可变变量（为了简单，下文将两个变量对象统一成一个变量对象讨论）。

![img](VO对象创建过程.png)

- 查找arguments作为属性

js编译器会检查函数参数，并将其作为VO对象的属性加入VO。

- 查找function声明的函数作为属性

js编译器按顺序查找代码中通过函数声明这种方式声明的函数（ES6之后可以省略function关键字，所以查找的是函数声明），将这个函数名称作为属性加入VO，属性值是该函数体保存的地址（堆地址）。

- 查找普通变量作为属性

js编译器按顺序查找代码中所有声明的变量，包括函数表达式中声明的变量，将这些变量名作为属性加入到VO对象中。

##### 关于var/let/const变量提升的问题

- var变量提升，只提升变量声明，不提升变量赋值，VO中var变量对应的属性值是undefined
- 如果var变量和function函数同名，因为function函数先被提升，当var变量被提升时发现已经有该属性了，所以VO中同名属性是function函数
- let/const变量也会被提升，但是不能在执行到let/const语句之前使用该变量

```javascript
// 1、直接打印一个变量
console.log(a); // 报错：Uncaught ReferenceError: a is not defined

// 2、先调用，后声明
console.log(a); // 报错：Uncaught ReferenceError: Cannot access 'a' before initialization
let a = 1;
```

从上面的两段代码中可以看出，let变量也是会被放入VO变量中的，但是与var不同的是，let/const对应的VO属性值不会被赋值undefined，因此虽然被提升了，但没有初始化，所以不能执行let/const语句之前被使用，这也称为“暂时性死区”。

##### 关于块级函数提升的问题

- ES6之后，大括号构成了一个新的作用域——块作用域
- 在块作用域中声明的function函数，严格模式下，function函数的作用范围只能在块作用域内，也只能在块作用域内被提升；非严格模式下不要在块级作用域中声明function函数，有条件地定义一个函数的一个更安全的方法是把函数表达式赋给一个变量。

详细：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions#%E5%9D%97%E7%BA%A7%E5%87%BD%E6%95%B0



2、建立作用域链

##### 词法作用域 vs 动态作用域

- JS的作用域属于词法作用域（词法作用域=静态作用域），它是一种规则、规范，使得JS引擎知道如何对要执行的JS代码进行词法分析，词法作用域在书写代码时就已经决定了。

- JS引擎通过词法作用域这一套规则，在执行时去查找当前作用域及嵌套子作用域下的变量标识符
- 作用域分为全局作用域、函数作用域、块作用域、eval作用域
- 



#### 执行阶段

创建阶段结束后，VO中保存了当前上下文中的声明的所有变量、函数以及this，但是没有到执行阶段时这些数据都是不可以访问的，到了执行阶段，VO变成了活动变量AO，里面保存的数据才可以被访问。





#### 销毁阶段



### 全局上下文的特殊点











